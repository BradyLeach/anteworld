#pragma once

#ifndef __INTERGEN_GENERATED__canvas_H__
#define __INTERGEN_GENERATED__canvas_H__

//@file Interface file for canvas interface generated by intergen
//See LICENSE file for copyright and license information

//host class: ::canvas

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>

#include <ot/glm/glm_meta.h>
namespace ot {
    class canvas;
}

class canvas;


namespace ot {

////////////////////////////////////////////////////////////////////////////////
/**
    Canvas API for 2D drawing.

    All colors are uchar4 in range 0-255!
    
    Example:
    iref<ot::canvas> cnv = ot::canvas::create("main");
    const uint fnt = cnv->load_font("ui/default.fnt");
    const uint img = cnv->load_image("ui/basic.imgset/airspeed");
    const uint img2 = cnv->load_image("ui/basic.imgset/airspeed_pointer");

    cnv->fill_rect(100, 100, 200, 200, uchar4(0x80));
    cnv->draw_text(
        fnt,
        100, 100,
        200, 200,
        ui::AnchorHCenter | ui::AnchorVCenter,
        "Lorem ipsum dolor sit amet, consectetur\n"
        "adipiscing elit. Nam vestibulum enim quis\n"
        "nisi tincidunt rhoncus. In hac habitasse\n"
        "platea dictumst. Vivamus rutrum posuere\n"
        "dui ut scelerisque.",
        uchar4(0xff),
        uchar4(0));

    cnv->fill_rect(100, 350, 150, 150, uchar4(0x80));

    cnv->draw_line(100, 350, 250, 350, uchar4(0, 0xff, 0, 0xff));
    cnv->draw_line(250, 350, 250, 500, uchar4(0, 0xff, 0, 0xff));
    cnv->draw_line(250, 500, 100, 500, uchar4(0, 0xff, 0, 0xff));
    cnv->draw_line(100, 500, 100, 350, uchar4(0, 0xff, 0, 0xff));

    static float angle = 0;

    // TRANSFORMATION EXAMPLE

    cnv->translate(100, 350);
    cnv->draw_image(img, 0, 0, uchar4(0xff));
    cnv->translate(75, 75);
    cnv->rotate(angle += 0.003f);
    cnv->draw_image(img2, -4.5f, -10.f, uchar4(0xff));

    // SCALE EXAMPLE

    cnv->load_identity();
    cnv->translate(400, 350);
    cnv->scale(0.5, 0.5);
    cnv->draw_image(img, 0, 0, uchar4(0xff));
**/
class canvas
    : public intergen_interface
{
public:

    // --- interface methods ---

    /// set all transformations to identity
    void load_identity();

    /// 2D translation
    void translate( float x, float y );

    /// rotation transformation in radians (CW)
    void rotate( float angle );

    /// scale transformation 1.0,1.0 means no scale
    void scale( float x, float y );

    /// rectangular clipping region, pixel outside this region will be discarded
    void set_clipping_rect( float x, float y, float w, float h );

    /// line parameters
    void set_line_params( float width, float smooth_size );

    /// push current state to stack (translation,rotation, clipping, line params)
    void push_state();

    /// pop state from stack
    void pop_state();

    /// filled rectangle (color is in range 0-255)
    void fill_rect( float x, float y, float w, float h, const uchar4& color );

    /// return font handle example: cnv->load_font("ui/default.fnt");
    /// supported fonts are in outerra/bin/ui folder
    /// additional fonts can be created with BMFont tool
    /// http://www.angelcode.com/products/bmfont/
    uint load_font( const coid::token& path );

    /// return image handle example: cnv->load_image("ui/basic.imgset/airspeed");
    /// there is example imageset in outerra/bin/ui/basic.imgset (basic.dds)
    /// images sets textures have to have format DXT5
    uint load_image( const coid::token& path );

    /// draw text line endings are supported (color is in range 0-255)
    void draw_text( uint font, float x, float y, const coid::token& text, const uchar4& color );

    /// new topdown experimental
    void draw_text2( uint font, float x, float y, const coid::token& text, const uchar4& color );

    /// (unfinished buggy in some cases...)
    /// draw text with anchor flags line endings are supported (color is in range 0-255)
    /// anchor flags:
    /// enum EAnchor {
    ///     AnchorLeft      = 0x01,
    ///     AnchorHCenter   = 0x02,
    ///     AnchorRight     = 0x03,
    ///     AnchorBottom    = 0x10,
    ///     AnchorVCenter   = 0x20,
    ///     AnchorTop       = 0x30,
    /// };
    void draw_text_wh( uint font, float x, float y, float w, float h, uint anchor, const coid::token& text, const uchar4& color, const uchar4& backcolor );

    ///
    void draw_text_ft( const coid::token& font, uint pixel_height, float x, float y, const coid::token& text, const uchar4& color );

    /// draw image its RGBA will be multiplied by color (color is in range 0-255)
    void draw_image( uint image, float x, float y, const uchar4& color );

    /// draw image its RGBA will be multiplied by color (color is in range 0-255)
    void draw_image_wh( uint image, float x, float y, float w, float h, const uchar4& color );

    /// draw image its RGBA will be multiplied by color (color is in range 0-255)
    void draw_image2( uint image, float x, float y, uint color );

    void draw_image2_scale( uint image, float x, float y, float w, float h, uint color );

    /// draw 2D line (width and smooth can be set with canvas::set_line_params) (color is in range 0-255)
    void draw_line( float x, float y, float x2, float y2, const uchar4& color );

    /// clear canvas
    void clear();

    /// clear canvas each frame (default: on)
    void set_auto_clear( bool on );

    ///
    void set_screen_offset( const float2& offset );

    /// set global modulation color
    void set_color( uint col );

    ///
    void set_visible( bool e );

    bool is_visible() const;

    // --- creators ---

    /// create named canvas if the canvas with given name exists it will return existing instance
    /// currently only one canvas instance "main" is supported
    static iref<canvas> create( const coid::token& name, bool auto_clear = true ) {
        return create<canvas>(0, name, auto_clear);
    }

    template<class T>
    static iref<T> create( T* _subclass_, const coid::token& name, bool auto_clear = true );

    // --- internal helpers ---

    virtual ~canvas() {
        if (_cleaner)
            _cleaner(this, 0);
    }

    ///Interface revision hash
    static const int HASHID = 4049827387;

    ///Interface name (full ns::class string)
    static const coid::tokenhash& IFCNAME() {
        static const coid::tokenhash _name = "ot::canvas";
        return _name;
    }

    int intergen_hash_id() const override final { return HASHID; }

    bool iface_is_derived( int hash ) const override final {
        return hash == HASHID;
    }

    const coid::tokenhash& intergen_interface_name() const override final {
        return IFCNAME();
    }

    static const coid::token& intergen_default_creator_static( EBackend bck ) {
        static const coid::token _dc("");
        static const coid::token _djs("ot::canvas@wrapper.js");
        static const coid::token _djsc("ot::canvas@wrapper.jsc");
        static const coid::token _dlua("ot::canvas@wrapper.lua");
        static const coid::token _dnone;

        switch(bck) {
        case IFC_BACKEND_CXX: return _dc;
        case IFC_BACKEND_JS:  return _djs;
        case IFC_BACKEND_JSC:  return _djsc;
        case IFC_BACKEND_LUA: return _dlua;
        default: return _dnone;
        }
    }

    //@return cached active interface of given host class
    //@note host side helper
    static iref<canvas> intergen_active_interface(::canvas* host);

    template<enum EBackend B>
    static void* intergen_wrapper_cache() {
        static void* _cached_wrapper=0;
        if (!_cached_wrapper) {
            const coid::token& tok = intergen_default_creator_static(B);
            _cached_wrapper = coid::interface_register::get_interface_creator(tok);
        }
        return _cached_wrapper;
    }

    void* intergen_wrapper( EBackend bck ) const override final {
        switch(bck) {
        case IFC_BACKEND_JS: return intergen_wrapper_cache<IFC_BACKEND_JS>();
        case IFC_BACKEND_JSC: return intergen_wrapper_cache<IFC_BACKEND_JSC>();
        case IFC_BACKEND_LUA: return intergen_wrapper_cache<IFC_BACKEND_LUA>();
        default: return 0;
        }
    }

    EBackend intergen_backend() const override { return IFC_BACKEND_CXX; }

    const coid::token& intergen_default_creator( EBackend bck ) const override final {
        return intergen_default_creator_static(bck);
    }

    ///Client registrator
    template<class C>
    static int register_client()
    {
        static_assert(std::is_base_of<canvas, C>::value, "not a base class");

        typedef iref<intergen_interface> (*fn_client)(void*, intergen_interface*);
        fn_client cc = [](void*, intergen_interface*) -> iref<intergen_interface> { return new C; };

        coid::token type = typeid(C).name();
        type.consume("class ");
        type.consume("struct ");

        coid::charstr tmp = "ot::canvas";
        tmp << "@client-4049827387" << '.' << type;

        coid::interface_register::register_interface_creator(tmp, cc);
        return 0;
    }

protected:

    static coid::comm_mutex& share_lock() {
        static coid::comm_mutex _mx(500, false);
        return _mx;
    }

    typedef void (*cleanup_fn)(canvas*, intergen_interface*);
    cleanup_fn _cleaner;

    canvas() : _cleaner(0)
    {}
};

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> canvas::create( T* _subclass_, const coid::token& name, bool auto_clear )
{
    typedef iref<T> (*fn_creator)(canvas*, const coid::token&, bool);

    static fn_creator create = 0;
    static const coid::token ifckey = "ot::canvas.create@4049827387";

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create) {
        log_mismatch("create", "ot::canvas.create", "@4049827387");
        return 0;
    }

    return create(_subclass_, name, auto_clear);
}

#pragma warning(push)
#pragma warning(disable : 4191)

inline void canvas::load_identity()
{ return VT_CALL(void,(),0)(); }

inline void canvas::translate( float x, float y )
{ return VT_CALL(void,(float,float),1)(x,y); }

inline void canvas::rotate( float angle )
{ return VT_CALL(void,(float),2)(angle); }

inline void canvas::scale( float x, float y )
{ return VT_CALL(void,(float,float),3)(x,y); }

inline void canvas::set_clipping_rect( float x, float y, float w, float h )
{ return VT_CALL(void,(float,float,float,float),4)(x,y,w,h); }

inline void canvas::set_line_params( float width, float smooth_size )
{ return VT_CALL(void,(float,float),5)(width,smooth_size); }

inline void canvas::push_state()
{ return VT_CALL(void,(),6)(); }

inline void canvas::pop_state()
{ return VT_CALL(void,(),7)(); }

inline void canvas::fill_rect( float x, float y, float w, float h, const uchar4& color )
{ return VT_CALL(void,(float,float,float,float,const uchar4&),8)(x,y,w,h,color); }

inline uint canvas::load_font( const coid::token& path )
{ return VT_CALL(uint,(const coid::token&),9)(path); }

inline uint canvas::load_image( const coid::token& path )
{ return VT_CALL(uint,(const coid::token&),10)(path); }

inline void canvas::draw_text( uint font, float x, float y, const coid::token& text, const uchar4& color )
{ return VT_CALL(void,(uint,float,float,const coid::token&,const uchar4&),11)(font,x,y,text,color); }

inline void canvas::draw_text2( uint font, float x, float y, const coid::token& text, const uchar4& color )
{ return VT_CALL(void,(uint,float,float,const coid::token&,const uchar4&),12)(font,x,y,text,color); }

inline void canvas::draw_text_wh( uint font, float x, float y, float w, float h, uint anchor, const coid::token& text, const uchar4& color, const uchar4& backcolor )
{ return VT_CALL(void,(uint,float,float,float,float,uint,const coid::token&,const uchar4&,const uchar4&),13)(font,x,y,w,h,anchor,text,color,backcolor); }

inline void canvas::draw_text_ft( const coid::token& font, uint pixel_height, float x, float y, const coid::token& text, const uchar4& color )
{ return VT_CALL(void,(const coid::token&,uint,float,float,const coid::token&,const uchar4&),14)(font,pixel_height,x,y,text,color); }

inline void canvas::draw_image( uint image, float x, float y, const uchar4& color )
{ return VT_CALL(void,(uint,float,float,const uchar4&),15)(image,x,y,color); }

inline void canvas::draw_image_wh( uint image, float x, float y, float w, float h, const uchar4& color )
{ return VT_CALL(void,(uint,float,float,float,float,const uchar4&),16)(image,x,y,w,h,color); }

inline void canvas::draw_image2( uint image, float x, float y, uint color )
{ return VT_CALL(void,(uint,float,float,uint),17)(image,x,y,color); }

inline void canvas::draw_image2_scale( uint image, float x, float y, float w, float h, uint color )
{ return VT_CALL(void,(uint,float,float,float,float,uint),18)(image,x,y,w,h,color); }

inline void canvas::draw_line( float x, float y, float x2, float y2, const uchar4& color )
{ return VT_CALL(void,(float,float,float,float,const uchar4&),19)(x,y,x2,y2,color); }

inline void canvas::clear()
{ return VT_CALL(void,(),20)(); }

inline void canvas::set_auto_clear( bool on )
{ return VT_CALL(void,(bool),21)(on); }

inline void canvas::set_screen_offset( const float2& offset )
{ return VT_CALL(void,(const float2&),22)(offset); }

inline void canvas::set_color( uint col )
{ return VT_CALL(void,(uint),23)(col); }

inline void canvas::set_visible( bool e )
{ return VT_CALL(void,(bool),24)(e); }

inline bool canvas::is_visible() const
{ return VT_CALL(bool,() const,25)(); }

#pragma warning(pop)

} //namespace

#endif //__INTERGEN_GENERATED__canvas_H__
